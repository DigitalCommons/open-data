#!/usr/bin/env ruby
# coding: utf-8
#
# This script controls a pipeline of processes that convert the original
# CSV data into the se_open_data standard, one step at a time.
#
# We aim to put only logic specific to this project in this file, and
# keep it brief and clear. Shared logic should go into the {SeOpenData}
# library.
#
# This script can be invoked directly, or as part of the {SeOpenData}
# library's command-line API {SeOpenData::Cli}. For example, this
# just runs the conversion step (or specifically: a script in the
# current directory called `converter`):
#
#     seod convert 
#
# And this runs the complete chain of commands generating and
# deploying the linked data for this project, as configured by
# `local.conf`:
#
#     seod run-all
#
# See the documentation on [`seod`]({SeOpenData::Cli}) for more
# information.

require 'se_open_data'
require 'se_open_data/csv/schema'
require 'se_open_data/csv/schema/types'
require 'csv'

# Code related to the ICA Youth-Network initiative data
module Converter

  # This defines the input CSV schema we expect (after clean-up and
  # index generation, excuted in the main method below.)
  Schema = SeOpenData::CSV::Schema.load_file('schema.yml')

  # A convenient alias...
  types = SeOpenData::CSV::Schema::Types

  def self.omit_na(str)
    str.to_s.match(%r{^\s*n\s*/\s*a\s*$}i)? nil : str
  end
  
  def self.territory(country, region, super_region)
    # Deal with ICA "Country" field data - We happen to know some
    # cases of country labels they use differ from those in
    # NormalizeCountry. Work around these until NormalizeCountry
    # incorporates our pull-request.
    #
    # When a country is supplied, we infer the region and super-region
    # downstream from here. The ICA don't currently use regions or
    # super-regions as territories, and we simply vaildate the Region
    # and Super-region fields.
    #
    # Raises an exception if an invalid case is found.
    case country.downcase
    when "democratic republic of congo"
      "CD"
    when "brasil"
      "BR"
    when "cameroun"
      "CM"
    when "the sudan"
      "SD"
    else
      NormalizeCountry(country, to: :alpha2) or
        raise "unrecognised country: #{country}"
    end
  end
  
  # This defines the schema mapping for ica-youth-network data into the
  # standard schema.
  #
  # The logic that maps the input field data is defined in the
  # do-block. It will be wrapped in a loop which reads the input file
  # and writes the output file. See the documentation for
  # {SeOpenData::CSV::Schema.converter}.
  #
  # See discussion here for some background on the conversion logic:
  # https://github.com/SolidarityEconomyAssociation/open-data/issues/11
  Converter = SeOpenData::CSV::Schema.converter(
    from_schema: Schema,
    to_schema: SeOpenData::CSV::Schemas::Latest,
#    output_csv_opts: {quote_empty: false}
  ) do | # These parameters match source schema field ids
         id:,
         name:,
         structure_type:,
         survey_structure_type:,
         typology:,
         primary_activity:,
         additional_activities:,
         other_activities:,
         region:,
         country:,
         description:,
         additional_description:,
         website:,
         email:,
         address:,
         city:,
         latitude:,
         longitude:,
         size:
         |
         # A mapping to the target schema field ids

         {
           id: @count? (@count += 1) : (@count = 1), # a hacky way to generate a sequential ID
           name: name,
           description: [description, additional_description].compact.join("<p>"),
           organisational_structure: TYPE_TO_ORG_STRUCT.fetch(types.to_sym survey_structure_type),
           primary_activity: ECONOMIC_ACTIVITY_TO_ACTIVITY.fetch(types.to_sym primary_activity),
           activities: (
             types.multivalue(additional_activities, delim: ",") do |it|
               ECONOMIC_ACTIVITY_TO_ACTIVITY.fetch(types.to_sym it)
             end
           ),
           street_address: omit_na(address), 
           locality: city,
           region: nil,
           postcode: nil,
           country_id: territory(country, nil, nil), # HACK, for geocoder, will replace later
           territory_id: territory(country, region, nil),
           homepage:  types.multivalue(omit_na website) do |it|
             types.normalise_url(it, default: nil)
           end,
           phone: nil,
           email: (omit_na email).to_s.empty? ? '' : types.normalise_email(email),
           twitter: nil,
           facebook: nil,
           companies_house_number: nil,
           qualifiers: (
             structure_type == "Coop Promoter/Supporter"? "Coop Promoter/Supporter" :
               additional_activities.to_s.include?("Coop Promoter/Supporter")?
                 "Coop Promoter/Supporter" : nil
           ),
           base_membership_type: BASE_MEMBERSHIP_TYPE.fetch(types.to_sym typology),
           latitude: types.normalise_float(latitude),
           longitude: types.normalise_float(longitude),
           geocontainer: nil,
           geocontainer_lat: nil,
           geocontainer_lon: nil,
         }
  end

  # CSV file transform - adds a new last column `Id` and inserts in it
  # a numeric index in each row.
  #
  # @param input - an input stream, or the name of a file to read
  # @param output - an output stream, or the name of a file to write
  def self.add_unique_ids(input:, output:)
    input = File.open(input) unless input.is_a? IO
    output = File.open(output, 'w') unless output.is_a? IO

    csv_opts = {}
    csv_opts.merge!(headers: true)

    csv_in = ::CSV.new(input, **csv_opts)
    csv_out = ::CSV.new(output)
    headers = nil
    i = 0
    csv_in.each do |row|
      unless headers
        headers = row.headers
        headers.push("Id")
        csv_out << headers
      end
      row['Id'] = i
      i+=1
      csv_out << row
    end

  ensure
    input.close
    output.close
  end

  # Entry point if invoked as a script.
  #
  # Expects a config file in the same directory as this script, called
  # either `default.conf` or `local.conf`. The latter is loaded
  # preferentially, otherwise the former is.
  #
  # See {SeOpenData::Config} for information about this file. It
  # defines the locations of various resources, and sets options on
  # the conversion process.
  def self.main
    # Find the config file...
    config = SeOpenData::Config.load(base: __dir__)

    # original src csv files 
    csv_to_standard = File.join(config.SRC_CSV_DIR, config.ORIGINAL_CSV)

    # Intermediate csv files
    added_ids = File.join(config.GEN_CSV_DIR, "with_ids.csv")
    cleared_errors = File.join(config.GEN_CSV_DIR, "cleared_errors.csv")

    # Output csv file
    output_csv = config.STANDARD_CSV

    ## handle limesurvey
    # generate the cleared error file
    SeOpenData::CSV.clean_up in_f: csv_to_standard, out_f: cleared_errors
    add_unique_ids input: cleared_errors, output: added_ids

    # Transforms the rows from Co-ops UK schema to our standard
    Converter.convert added_ids, output_csv
  end

  private

  TYPE_TO_ORG_STRUCT = {
    # cooperativa_de_consumo_usuario_final: "Consumer/User coop",
    # cooperative_de_consommateur_rice_s: "Consumer/User coop",
    final_consumer_user_cooperative: "Consumer/User coop",
    cooperativa_de_multiples_actores: "Multi-stakeholder co-operative",
    # cooperative_pluri_acteurs: "Multi-stakeholder co-operative",
    multi_stakeholder_cooperative: "Multi-stakeholder co-operative",
    cooperativa_de_produccion: "Producer co-operative",
    # cooperative_de_producteur_rice_s_dont_agricole: "Producer co-operative",
    producer_cooperative: "Producer co-operative",
    # cooperativa_de_trabajo_y_empleo: "Self-employed",
    # cooperativa_di_lavoro: "Self-employed",
    work_and_employment_cooperative: "Self-employed",
    # cooperative_de_travailleur_se_s: "Workers co-operative",
  }

  ECONOMIC_ACTIVITY_TO_ACTIVITY = {
    education_health_social_work: "Education / health / social work",
    all: "All",
    financial_services: "Financial Services",
    fishing: "Fishing",
    housing: "Housing",
    insurance: "Insurance",
    other_services: "Other services",
    wholesale_and_retail_trade: "Wholesale and retail trade",
    agriculture: "Agriculture",
    utilities: "Utilities",
    industry: "Industry",
  }

  BASE_MEMBERSHIP_TYPE = {
    consumer_user_coops: "Consumer/Users",
    others: "Others",
    producer_coops: "Producers",
    worker_coops: "Workers",
    multi_stakeholder_coops: "Multi - stakeholders",
    residents: "Residents",
  }
end

# Run the entry point if we're invoked as a script
# This just does the csv conversion.
Converter.main if __FILE__ == $0


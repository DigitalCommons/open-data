#!/usr/bin/env ruby
# coding: utf-8
#
# This script controls a pipeline of processes that convert the original
# CSV data into the se_open_data standard, one step at a time.
#
# We aim to put only logic specific to this project in this file, and
# keep it brief and clear. Shared logic should go into the {SeOpenData}
# library.
#
# This script can be invoked directly, or as part of the {SeOpenData}
# library's command-line API {SeOpenData::Cli}. For example, this
# just runs the conversion step (or specifically: a script in the
# current directory called `converter`):
#
#     seod convert 
#
# And this runs the complete chain of commands generating and
# deploying the linked data for this project, as configured by
# `settings/config.txt`:
#
#     seod run-all
#
# See the documentation on [`seod`]({SeOpenData::Cli}) for more
# information.

require 'se_open_data'
require 'se_open_data/config'
require 'se_open_data/csv/add_postcode_lat_long'
require 'se_open_data/csv/schema'
require 'se_open_data/csv/schema/types'
require 'csv'

# FIXME
# postcodes eh?
# Sector tag - what taxonomy?

# Code related to the DotCoop SSE initiative data
module DotCoop

  
  PostcodeIndexSchema = SeOpenData::CSV::Schema.new(
    id: :postcode_index,
    name: "Registrant postcode index",
    version: 20200810, 
    comment: 'Initial version, may require amendment',

    fields: [
      {id: :uri,
       header: 'URI',
       desc: "The registrant's linked-data URI identifying it",
       comment: '',
      },
      {id: :name,
       header: 'Name',
       desc: "The registrant's name",
       comment: '',
      },
      {id: :postcode,
       header: 'Postcode',
       desc: "The registrant's postcode",
       comment: '',
      },
    ]
  )

  # The output schema
  StdSchema = SeOpenData::CSV::Schemas::Latest
  
  def self.parse_dotcoop_organisation(org)
    (dpid, orgname, address, domains, tags) =
      org.values_at('id', 'name', 'address', 'domains', 'tags')
    tags ||= []
    domains ||= []
    address ||= {}
    
    domain_urls = domains.map do |domain|
      "http://#{domain['name']}"
    end
    
    (street_address, city, region, post_code, country) =
      address.values_at('streetAddress', 'city', 'region', 'postCode', 'country')
                                            
    tag_index = tags.reduce({}) do |index, tag|
      name, value = tag.values_at('name','value')
      if index.has_key? name
        raise "duplicate tag #{name} in org #{orgname} DeskproID #{dpid}"
      end
      index[name] = value

      index
    end

    sector = tag_index['Sector']
    verification_status = tag_index['verificationStatus']
    orgid = tag_index['OrgID']
    if orgid.to_s == ''
      raise "missing OrgID tag in org #{orgname} DeskproID #{dpid}"
    end

    if orgid !~ /^[\w_=-]{6,}$/
      raise "invalid OrgID tag in org #{orgname} DeskproID #{dpid}: #{orgid}"
    end
    
    fields = {
      id: orgid,
      name: orgname,
      description: nil,
      organisational_structure: nil,
      primary_activity: nil,
      activities: nil,
      street_address: street_address,
      locality: city,
      region: region,
      postcode: post_code,
      country_id: nil,
      territory_id: nil,
      homepage: domain_urls.join(';'),
      phone: nil,
      email: nil,
      twitter: nil,
      facebook: nil,
      companies_house_number: nil,
      qualifiers: nil,
      base_membership_type: nil,
      latitude: nil,
      longitude: nil,
      geocontainer: nil,
      geocontainer_lat: nil,
      geocontainer_lon: nil,
      dotcoop_sector: sector,
      dotcoop_verification_status: verification_status,
    }

    
    CSV::Row.new(
      StdSchema.field_headers,
      StdSchema.fields.map do |field|
        unless fields.has_key? field.id
          raise "missing field #{field.id} in org parser: #{org}"
        end
        fields[field.id]
      end
    )
  end
  
  def self.dotcoop_import(json_file, csv_file)
    json = IO.read(json_file)
    data = JSON.parse(json)
    
    # Check it's an object
    unless data.is_a? Hash
      raise "Top level JSON element should be an object, in #{json_file}"
    end

    generated = data['generated'] # FIXME do something with this?
    organisations = data['organisations']
    
    unless organisations.is_a? Array
      raise "Top `organisations` JSON element should be an array, in #{json_file}"
    end
    
    CSV.open(csv_file, 'w', headers: StdSchema.field_headers, write_headers: true) do |csv|
      organisations.each do |org|
        # Check it's a hash
        unless org.is_a? Hash
          raise "`organisation` JSON elements should be an objects, in #{json_file}"
        end

        # Parse it
        row = parse_dotcoop_organisation(org)

        # Write it
        csv << row
      end
    end
  end
  
           
  # Entry point if invoked as a script.
  #
  # See {SeOpenData::Config} for information about this file. It
  # defines the locations of various resources, and sets options on
  # the conversion process.
  def self.main
    # Find the config file...
    config = SeOpenData::Config.load

    # original src JSON file
    original_json = File.join(config.SRC_CSV_DIR, config.ORIGINAL_CSV)
    imported_csv = File.join(config.GEN_CSV_DIR, "standard.csv")
#    reports_dir = File.join(config.TOP_OUTPUT_DIR, 'reports')
    output_csv = config.STANDARD_CSV

    dotcoop_import original_json, imported_csv
    
    # Get the Geoapify API key
    pass = SeOpenData::Utils::PasswordStore.new(use_env_vars: config.USE_ENV_PASSWORDS)
    api_key = pass.get config.GEOCODER_API_KEY_PATH

    SeOpenData::CSV.add_postcode_lat_long(
      infile: imported_csv,
      outfile: output_csv,
      api_key: api_key,
      lat_lng_cache: config.POSTCODE_LAT_LNG_CACHE,
      postcode_global_cache: config.GEODATA_CACHE,
      replace_address: "force")
    
#    document_geocoder(converted: imported_csv, postcode_global_cache: config.GEODATA_CACHE,
#                      docs_folder: reports_dir, api_key: api_key)

  rescue => e
    raise "error transforming #{original_json} into #{output_csv}: #{e.message}"
  end

  private

  # @param postcode_global_cache CSV file where all the postcodes are
  # kept (note that this will be a json in the future @param converted
  # the file used for geocoding @param docs_folder generated
  # documentation folder
  def self.document_geocoder(converted: nil, docs_folder:,
                             postcode_global_cache:, api_key:)
    geoapify = SeOpenData::CSV::Standard::GeoapifyStandard::Geocoder.new(api_key)
    header = StdSchema.field(:homepage).header
    geoapify.gen_geo_report(postcode_global_cache, 0.05, docs_folder, converted, [header])
  end


end

# Run the entry point if we're invoked as a script
# This just does the csv conversion.
DotCoop.main if __FILE__ == $0

